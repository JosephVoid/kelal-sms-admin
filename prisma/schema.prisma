generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model accounts {
  id           String         @id(map: "Accounts_pkey") @default(uuid()) @db.Uuid
  name         String         @db.VarChar
  balance      Float
  updatedAt    DateTime?      @db.Timestamp(6)
  createdAt    DateTime?      @db.Timestamp(6)
  isBanned     Boolean?
  apps         apps[]
  logging      logging[]
  logs         logs[]
  topups       topups[]
  useraccounts useraccounts[]
}

model apps {
  id        String     @id(map: "Apps_pkey") @default(uuid()) @db.Uuid
  accountId String     @db.Uuid
  updatedAt DateTime?  @db.Timestamp(6)
  createdAt DateTime?  @db.Timestamp(6)
  name      String?    @db.VarChar(200)
  accounts  accounts   @relation(fields: [accountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Apps_accountId_fkey")
  keys      keys[]
  logging   logging[]
  logs      logs[]
  messages  messages[]
}

model keys {
  id        String    @id(map: "Keys_pkey") @default(uuid()) @db.Uuid
  appId     String    @db.Uuid
  keyHash   String    @db.VarChar
  name      String    @db.VarChar
  expiresOn DateTime  @db.Timestamp(6)
  lastUsed  DateTime? @db.Timestamp(6)
  updatedAt DateTime? @db.Timestamp(6)
  createdAt DateTime? @db.Timestamp(6)
  apps      apps      @relation(fields: [appId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Keys_appId_fkey")
  logs      logs[]
}

model logs {
  id            String        @id(map: "Logs_pkey") @db.Uuid
  userId        String?       @db.Uuid
  accountId     String?       @db.Uuid
  appId         String?       @db.Uuid
  userAccountId String?       @db.Uuid
  keyId         String?       @db.Uuid
  messageId     String?       @db.Uuid
  serviceId     String?       @db.Uuid
  providerId    String?       @db.Uuid
  request       Json?         @db.Json
  requestTime   DateTime?     @db.Timestamp(6)
  response      Json?         @db.Json
  responseTime  DateTime?     @db.Timestamp(6)
  logMessage    String        @db.VarChar
  updatedAt     DateTime?     @db.Timestamp(6)
  createdAt     DateTime?     @db.Timestamp(6)
  accounts      accounts?     @relation(fields: [accountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_accountId_fkey")
  apps          apps?         @relation(fields: [appId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_appId_fkey")
  keys          keys?         @relation(fields: [keyId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_keyId_fkey")
  messages      messages?     @relation(fields: [messageId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_messageId_fkey")
  providers     providers?    @relation(fields: [providerId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_providerId_fkey")
  services      services?     @relation(fields: [serviceId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_serviceId_fkey")
  useraccounts  useraccounts? @relation(fields: [userAccountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_userAccountId_fkey")
  users         users?        @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Logs_userId_fkey")
}

model messages {
  id          String    @id(map: "Messages_pkey") @db.Uuid
  appId       String    @db.Uuid
  sentTo      String    @db.VarChar
  content     String    @db.VarChar
  serviceId   String    @db.Uuid
  status      status
  providerId  String    @db.Uuid
  externalId  String?   @db.VarChar
  sentAt      DateTime? @db.Timestamp(6)
  deliveredAt DateTime? @db.Timestamp(6)
  updatedAt   DateTime? @db.Timestamp(6)
  createdAt   DateTime? @db.Timestamp(6)
  logs        logs[]
  apps        apps      @relation(fields: [appId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Messages_appId_fkey")
  providers   providers @relation(fields: [providerId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Messages_providerId_fkey")
  services    services  @relation(fields: [serviceId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Messages_serviceId_fkey")
}

model providers {
  id             String     @id(map: "Providers_pkey") @db.Uuid
  name           String
  url            String     @db.VarChar
  headers        Json?      @db.Json
  bodySchema     Json?      @db.Json
  costPerMessage Float
  updatedAt      DateTime?  @db.Timestamp(6)
  createdAt      DateTime?  @db.Timestamp(6)
  failCount      BigInt?    @default(0)
  successField   String?    @db.VarChar
  successValue   String?    @db.VarChar
  messageIdField String?    @db.VarChar
  logging        logging[]
  logs           logs[]
  messages       messages[]
}

model services {
  id              String     @id(map: "Services_pkey") @db.Uuid
  name            String
  pricePerMessage Float
  updatedAt       DateTime?  @db.Timestamp(6)
  createdAt       DateTime?  @db.Timestamp(6)
  logging         logging[]
  logs            logs[]
  messages        messages[]
}

model useraccounts {
  id        String    @id(map: "UserAccounts_pkey") @default(uuid()) @db.Uuid
  userId    String    @db.Uuid
  accountId String    @db.Uuid
  role      roles
  updatedAt DateTime? @db.Timestamp(6)
  createdAt DateTime? @db.Timestamp(6)
  logs      logs[]
  accounts  accounts  @relation(fields: [accountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "UserAccounts_accountId_fkey")
  users     users     @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "UserAccounts_userId_fkey")
}

model users {
  id           String         @id(map: "Users_pkey") @default(uuid()) @db.Uuid
  fullName     String         @db.VarChar
  email        String         @unique @db.VarChar
  password     String         @db.VarChar
  updatedAt    DateTime?      @db.Timestamp(6)
  createdAt    DateTime?      @db.Timestamp(6)
  phone        String?        @db.VarChar
  logging      logging[]
  logs         logs[]
  useraccounts useraccounts[]
}

model otp {
  id        String    @id @default(uuid()) @db.Uuid
  otp       String?   @db.VarChar
  expiresOn DateTime? @db.Time(6)
  email     String?   @db.VarChar
  createdOn DateTime? @db.Timestamp(6)
}

model logging {
  id                String     @id @db.Uuid
  user_id           String?    @db.Uuid
  source            String?
  account_id        String?    @db.Uuid
  app_id            String?    @db.Uuid
  service_id        String?    @db.Uuid
  provider_id       String?    @db.Uuid
  user_request      Json?
  user_response     Json?
  provider_request  Json?
  provider_response Json?
  request_time      DateTime?  @db.Timestamp(6)
  response_time     DateTime?  @db.Timestamp(6)
  log_message       String?
  verbose_message   String?
  created_at        DateTime?  @default(now()) @db.Timestamp(6)
  message_id        String?    @db.Uuid
  accounts          accounts?  @relation(fields: [account_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "AccountFK")
  apps              apps?      @relation(fields: [app_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "AppFK")
  providers         providers? @relation(fields: [provider_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "ProviderFK")
  services          services?  @relation(fields: [service_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "ServiceFK")
  users             users?     @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "UserFK")
}

model topups {
  id        String       @id @default(uuid()) @db.Uuid
  accountId String       @db.Uuid
  amount    Float?
  txnId     String?      @db.VarChar
  updatedAt DateTime?    @db.Timestamp(6)
  createdAt DateTime?    @db.Timestamp(6)
  type      topuptype?
  status    topupstatus?
  userName  String?      @db.VarChar
  accounts  accounts     @relation(fields: [accountId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "TopUpFK")
}

enum roles {
  owner
  viewer
  admin
}

enum status {
  pending
  sent
  delivered
  failed
}

enum topupstatus {
  REQUEST
  APPROVED
  DENIED
  AUTOMATIC
}

enum topuptype {
  MANUAL
  CHAPA
}
